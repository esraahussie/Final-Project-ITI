@model Uber.DAL.Entities.Ride

@{
    ViewData["Title"] = "Ride Details";
    var isDriver = User.IsInRole("Driver") || User.IsInRole("Admin");
    var isUser = User.IsInRole("User") || User.IsInRole("Admin");
    string backHref = User.IsInRole("Driver") ? "/Driver/Dashboard" : "/Home";
}

<!-- Map CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Fallback CDN links in case the main ones fail -->
<script>
    // Check if Leaflet loaded from primary CDN
    if (typeof L === 'undefined') {
        // Load from fallback CDN
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css';
        document.head.appendChild(link);
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js';
        script.onload = function() {
        };
        script.onerror = function() {
            console.error('Both Leaflet CDNs failed to load');
        };
        document.head.appendChild(script);
    }
</script>

<style>
    #rideMap {
        width: 100%;
        height: 400px;
        border-radius: 10px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        position: relative;
        z-index: 1;
        background-color: #f0f0f0; /* Add background color to make it visible */
        border: 2px solid #ddd; /* Add border to make it more visible */
    }
    
    /* Ensure the map container is properly sized */
    .map-container {
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        position: relative;
    }
    
    /* Force the map to be visible */
    .map-container #rideMap {
        min-height: 400px;
        display: block !important;
        visibility: visible !important;
    }
    
    .map-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 15px;
    }
    
    .map-info-item {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        text-align: center;
    }
    
    .map-info-item h5 {
        margin: 0 0 10px 0;
        color: #6c757d;
        font-size: 14px;
    }
    
    .map-info-item p {
        margin: 0;
        font-weight: bold;
        color: #495057;
        font-size: 18px;
    }
    
    /* Rating stars styles */
    .star {
        font-size: 40px !important;
        margin: 0 8px !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .star:hover {
        color: #ffc107 !important;
        transform: scale(1.1);
    }

    .star:hover ~ .star {
        color: #ddd !important;
    }

    /* Rating modal enhancements */
    .modal-content {
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .rating-stars {
        margin: 30px 0;
    }
    
    #selectedRating {
        font-size: 20px;
        margin: 20px 0;
        min-height: 30px;
    }
    
    .modal-actions button {
        font-size: 16px;
        padding: 12px 24px;
        margin: 0 10px;
    }
    
    /* Driver workflow button enhancements */
    .action-buttons button {
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .action-buttons button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .action-buttons button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
    }
    
    /* Ride price display */
    #completedRidePrice {
        animation: fadeInUp 0.5s ease-out;
    }
    keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
</style>

<div style="max-width: 1000px; margin: 0 auto; padding: 20px;">
    <div style="text-align: center; margin-bottom: 30px;">
        <h2 style="color: #007bff;">üöó Active Ride</h2>
        <div style="display: inline-block; padding: 8px 16px; background-color: #28a745; color: white; border-radius: 20px; font-weight: bold;">
            Ride ID: @Model.Id
        </div>
    </div>

    <!-- Ride Status -->
    <div class="ride-status-info" style="background-color: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
        <h4 style="color: #28a745; margin: 0;">
            @switch (Model.Status)
            {
                case Uber.DAL.Enums.RideStatus.Pending:
                    <text>‚è≥ Ride Pending</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Accepted:
                    <text>‚úÖ Ride Accepted</text>
                    break;
                case Uber.DAL.Enums.RideStatus.InProgress:
                    <text>üöÄ Ride In Progress</text>
                    break;
                case Uber.DAL.Enums.RideStatus.DriverWaiting:
                    <text>üöó Driver Waiting at Pickup</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Completed:
                    <text>‚úÖ Ride Completed</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Cancelled:
                    <text>‚ùå Ride Cancelled</text>
                    break;
                default:
                    <text>‚úÖ Ride Accepted</text>
                    break;
            }
        </h4>
        <p style="margin: 10px 0 0 0; color: #2d5a2d;">
            @switch (Model.Status)
            {
                case Uber.DAL.Enums.RideStatus.Pending:
                    <text>Waiting for driver to accept your ride request.</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Accepted:
                    <text>Your ride is confirmed and on the way!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.DriverWaiting:
                    <text>Driver has arrived at pickup location. Please proceed to the vehicle.</text>
                    break;
                case Uber.DAL.Enums.RideStatus.InProgress:
                    <text>Your ride is now in progress!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Completed:
                    <text>Your ride has been completed successfully!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Cancelled:
                    <text>This ride has been cancelled.</text>
                    break;
                default:
                    <text>Your ride is confirmed and on the way!</text>
                    break;
            }
        </p>
    </div>

    <!-- Map Section -->
    <div class="map-container">
        <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üó∫Ô∏è Ride Route</h4>
        <div id="rideMap">
        </div>
        
        
        
        <!-- SignalR Status Indicator -->
        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; text-align: center;">
            <strong>SignalR Status:</strong> 
            <span id="signalRStatus" style="padding: 5px 10px; border-radius: 3px; font-weight: bold; margin-left: 10px;">
                Connecting...
            </span>
        </div>
        
        
        
        <div class="map-info">
            <div class="map-info-item">
                <h5>üöÄ Price</h5>
                <p id="price">Calculating...</p>
            </div>
            <div class="map-info-item">
                <h5 style="color: #6c757d; margin-bottom: 10px;">üîÑ Status</h5>
                <span id="statusBadge" style="padding: 5px 12px; background-color: #28a745; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">
                    @Model.Status.ToString()
                </span>
            </div>
            <div class="map-info-item">
                <h5>üìè Distance</h5>
                <p id="routeDistance">Calculating...</p>
            </div>
            <div class="map-info-item">
                <h5>‚è±Ô∏è Duration</h5>
                <p id="routeDuration">Calculating...</p>
            </div>
        </div>
    </div>


    <!-- Driver Information (if user is viewing) -->
    @if (isUser && Model.Driver != null)
    {
        <div style="background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
            <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üë®‚Äçüíº Driver Information</h4>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="width: 60px; height: 60px; background-color: #007bff; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
                    @(Model.Driver.UserName?.Substring(0, 1).ToUpper() ?? "D")
                </div>
                
                <div>
                    <h5 style="margin: 0; color: #495057;">@Model.Driver.UserName</h5>
                    <p style="margin: 5px 0 0 0; color: #6c757d;">Your assigned driver</p>
                </div>
            </div>
        </div>
    }

    <!-- User Information (if driver is viewing) -->
    @if (isDriver && Model.User != null)
    {
        <div style="background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
            <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üë§ Passenger Information</h4>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="width: 60px; height: 60px; background-color: #6c757d; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
                    @(Model.User.UserName?.Substring(0, 1).ToUpper() ?? "U")
                </div>
                
                <div>
                    <h5 style="margin: 0; color: #495057;">@Model.User.UserName</h5>
                    <p style="margin: 5px 0 0 0; color: #6c757d;">Your passenger</p>
                </div>
            </div>
        </div>
    }

    <!-- Action Buttons -->
    <div class="action-buttons" style="text-align: center; margin-top: 30px;">
        @if (isDriver)
        {
            <!-- All driver buttons are always present but controlled by JavaScript -->
            <button id="arrivedAtPickupBtn" onclick="driverArrived()" style="padding: 15px 30px; background-color: #17a2b8; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px; display: none;">
                üöó Arrived at Pickup
            </button>
            
            <button id="startRideBtn" onclick="startRide()" style="padding: 15px 30px; background-color: #007bff; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px; display: none;">
                üöÄ Start Ride
            </button>
            
            <button id="completeRideBtn" onclick="completeRide()" style="padding: 15px 30px; background-color: #28a745; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px; display: none;">
                ‚úÖ Complete Ride
            </button>
        }
        
        <!-- Cancel Ride Button - Visible for both roles unless ride is completed or cancelled -->
        @if (Model.Status != Uber.DAL.Enums.RideStatus.Completed && Model.Status != Uber.DAL.Enums.RideStatus.Cancelled)
        {
            <button id="cancelRideBtn" onclick="cancelRide()" style="padding: 15px 30px; background-color: #dc3545; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px;">
                ‚ùå Cancel Ride
            </button>
        }
        
        <!-- Back to Home Button - Only visible when ride is completed or cancelled -->
        @if (Model.Status == Uber.DAL.Enums.RideStatus.Completed || Model.Status == Uber.DAL.Enums.RideStatus.Cancelled)
        {
        <a href="/Home" style="display: inline-block; padding: 15px 30px; background-color: #6c757d; color: white; text-decoration: none; border-radius: 8px; font-size: 16px; margin: 0 10px;">
            üè† Back to Home
        </a>
        }
    </div>

    <!-- Rating Modal -->
    <div id="ratingModal" class="modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
        <div class="modal-content" style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px;">
            <div class="modal-header" style="border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 20px;">
                <h3 id="ratingModalTitle" style="margin: 0; color: #495057;">Rate Your Experience</h3>
                <span class="close" onclick="closeRatingModal()" style="color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;">&times;</span>
            </div>
            
            <div class="modal-body">
                <p id="ratingModalMessage" style="margin-bottom: 20px; color: #6c757d;">Please rate your experience with this ride.</p>
                
                <div class="rating-stars" style="text-align: center;">
                    <span class="star" data-rating="1">‚òÖ</span>
                    <span class="star" data-rating="2">‚òÖ</span>
                    <span class="star" data-rating="3">‚òÖ</span>
                    <span class="star" data-rating="4">‚òÖ</span>
                    <span class="star" data-rating="5">‚òÖ</span>
                </div>
                
                <div id="selectedRating" style="text-align: center; margin-bottom: 20px;">
                    <span style="font-size: 18px; color: #6c757d;">Select a rating</span>
                </div>
                
                <div class="modal-actions" style="text-align: center;">
                    <button id="submitRatingBtn" onclick="submitRating()" style="padding: 10px 20px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;" disabled>
                        Submit Rating
                    </button>
                    <button onclick="closeRatingModal()" style="padding: 10px 20px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Real-time Updates -->
    <div id="rideUpdates" style="margin-top: 30px; padding: 20px; background-color: #f8f9fa; border-radius: 8px; display: none;">
        <h4 style="color: #495057; margin-bottom: 15px;">üîÑ Live Updates</h4>
        <div id="updateContent"></div>
    </div>
</div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
<script>

    window.addEventListener("load", initializeMap);

    let connection;
    let isConnected = false;
    let map, pickupMarker, dropoffMarker, routeLine;
    let currentRating = 0;
    let ratingTarget = ''; // 'user' or 'driver'
    let currentRideId = @Model.Id;

    // Initialize map
    function initializeMap() {
             // Prevent multiple map initializations
             if (window.mapInitialized) {
                 return;
             }
        
        // Check if Leaflet is loaded
        if (typeof L === 'undefined') {
            console.error('Leaflet library not loaded!');
            return;
        }
        
        // Validate coordinates
        const startLat = @Model.StartLat;
        const startLng = @Model.StartLng;
        const endLat = @Model.EndLat;
        const endLng = @Model.EndLng;
        
        // Check if coordinates are valid numbers
        if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) {
            console.error('Invalid coordinates detected, using fallback coordinates');
            // Use fallback coordinates (New York City area)
            const fallbackStartLat = 40.7128;
            const fallbackStartLng = -74.0060;
            const fallbackEndLat = 40.7589;
            const fallbackEndLng = -73.9851;
            
            initializeMapWithCoordinates(fallbackStartLat, fallbackStartLng, fallbackEndLat, fallbackEndLng);
            return;
        }
        
        initializeMapWithCoordinates(startLat, startLng, endLat, endLng);
    }
    
    function initializeMapWithCoordinates(startLat, startLng, endLat, endLng) {
        try {
            // Create map centered between pickup and destination
            const centerLat = (startLat + endLat) / 2;
            const centerLng = (startLng + endLng) / 2;
            
            map = L.map('rideMap').setView([centerLat, centerLng], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Add pickup and dropoff markers
            pickupMarker = L.marker([startLat, startLng], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    iconSize: [32, 32]
                })
            }).addTo(map).bindPopup("üöÄ Pickup Location").openPopup();

            dropoffMarker = L.marker([endLat, endLng], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684909.png',
                    iconSize: [32, 32]
                })
            }).addTo(map).bindPopup("üéØ Destination").openPopup();

            // Draw route between points
            drawRouteWithCoordinates(startLat, startLng, endLat, endLng);
             
             // Mark map as initialized
             window.mapInitialized = true;
        } catch (error) {
            console.error('Error initializing map:', error);
        }
    }

    
    async function drawRouteWithCoordinates(startLat, startLng, endLat, endLng) {
        try {
            const start = [startLat, startLng];
            const end = [endLat, endLng];

            const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`);
            const data = await response.json();

            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const path = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                // Remove existing route line if any
                if (routeLine) {
                    map.removeLayer(routeLine);
                }

                // Draw new route line
                routeLine = L.polyline(path, { color: '#007bff', weight: 4, opacity: 0.8 }).addTo(map);

                // Fit map to show entire route
                map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });

                // Update distance and duration
                const distance = (route.distance / 1000).toFixed(2);
                const duration = (route.duration / 60).toFixed(1);
                const price = (distance * 7 + duration * 1.5 + 7).toFixed(2)

                document.getElementById('routeDistance').textContent = distance + ' km';
                document.getElementById('routeDuration').textContent = duration + ' min';
                document.getElementById('price').textContent = price + 'pound';
            }
        } catch (error) {
            console.error('Error drawing route:', error);
            document.getElementById('routeDistance').textContent = 'Error';
            document.getElementById('routeDuration').textContent = 'Error';
            document.getElementById('price').textContent = 'Error';

         }
     }

                  // Function to join driver group if user is a driver
         async function joinDriverGroupIfNeeded() {
             @if (isDriver)
             {
                 <text>
                 const driverId = '@User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value';
                 if (driverId && driverId !== '') {
                     try {
                         await connection.invoke("JoinDriverGroup", driverId);
                     } catch (err) {
                         console.error("Failed to join driver group:", err);
                     }
                 }
                 </text>
        }
    }

    // Initialize SignalR connection for real-time updates
    async function initializeConnection() {
        try {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/rideHub", { 
                    skipNegotiation: true,
                    transport: signalR.HttpTransportType.WebSockets
                })
                .withAutomaticReconnect()
                .build();

            // Join the ride group for updates
            await connection.start();
                 
                 // Join the ride group
            await connection.invoke("JoinRideGroup", "ride-@Model.Id");
 
                 // Join driver group if user is a driver
                 await joinDriverGroupIfNeeded();
                 
                 isConnected = true;
                 updateSignalRStatus("Connected", "#28a745");
                 
                 // Set up SignalR event listeners
                 setupSignalRListeners();
                 
                 // Add connection state monitoring
                 connection.onclose(async (error) => {
                     isConnected = false;
                     updateSignalRStatus("Disconnected", "#dc3545");
                     
                     // Try to reconnect after a delay
                     setTimeout(async () => {
                         await initializeConnection();
                     }, 3000);
                 });
                 
                 // Add periodic connection health check
                 setInterval(async () => {
                     if (connection && connection.state === signalR.HubConnectionState.Connected) {
                         isConnected = true;
                         updateSignalRStatus("Connected", "#28a745");
                     } else if (connection && connection.state !== signalR.HubConnectionState.Connected) {
                         isConnected = false;
                         updateSignalRStatus("Reconnecting...", "#ffc107");
                         try {
                             await initializeConnection();
                         } catch (error) {
                             console.error("Health check reconnection failed:", error);
                         }
                     }
                 }, 10000); // Check every 10 seconds
                 
                 connection.onreconnecting((error) => {
                     isConnected = false;
                     updateSignalRStatus("Reconnecting...", "#ffc107");
                 });
                 
                 connection.onreconnected((connectionId) => {
            isConnected = true;
                     updateSignalRStatus("Connected", "#28a745");
                 });

        } catch (err) {
            console.error("SignalR Connection Error:", err);
                 isConnected = false;
                 updateSignalRStatus("Error", "#dc3545");
             }
         }
    
         // Function to update SignalR status display
     function updateSignalRStatus(status, color) {
         const statusElement = document.getElementById('signalRStatus');
         if (statusElement) {
             statusElement.textContent = status;
             statusElement.style.backgroundColor = color;
             statusElement.style.color = 'white';
         }
     }
     
              // Function to set up SignalR event listeners
         function setupSignalRListeners() {
             // Prevent duplicate event listeners
             if (window.signalRListenersSet) {
                 return;
             }
             
             // Listen for real-time ride updates

              // Event listener for driver workflow
              connection.on("DriverArrived", function (rideId) {
                  if (rideId == @Model.Id) {
                      // Update UI to show driver arrived
                      updateRideStatusDisplay("DriverWaiting");
                      updateButtonVisibility("DriverWaiting");
                      
                      // Show success message
                      alert("Driver has arrived at pickup location!");
                  }
              });

              // Event listener for when ride starts
              connection.on("RideStarted", function (rideId) {
                  if (rideId == @Model.Id) {
                      // Update UI to show ride started
                      updateRideStatusDisplay("InProgress");
                      updateButtonVisibility("InProgress");
                      
                      // Show success message
                      alert("Ride has started!");
                  }
              });

              // Event listener for when ride is completed
              connection.on("RideCompleted", function (rideId) {
                  if (rideId == @Model.Id) {
                      console.log('RideCompleted SignalR event received for ride:', rideId);
                      
                      // Update UI to show ride completed
                      updateRideStatusDisplay("Completed");
                      
                      // Show rating modal only for drivers to rate users
                      if (@isDriver.ToString().ToLower()) {
                          showRatingModal('user', 'Please rate your passenger for this ride.');
                      }
                  }
              });

              // Event listener for when ride is cancelled
              connection.on("RideCancelled", function (rideId) {
                  if (rideId == @Model.Id) {
                      // Update ride status display immediately
                      updateRideStatusDisplay("Cancelled");
                      updateButtonVisibility("Cancelled");
                      
                      // Show the Back to Home button
                      showBackToHomeButton();
                      
                      // Show cancellation message
                      alert("Ride has been cancelled.");
                  }
              });

             // Rating event listeners
             connection.on("UserRated", function (rideId, rating) {
                 if (rideId == @Model.Id) {
                     // Show success message for user rating
                     alert(`User has been rated ${rating} star${rating > 1 ? 's' : ''}!`);
                     
                     // Show rating modal for user to rate driver (only if user hasn't rated yet)
                     if (!@isDriver.ToString().ToLower()) {
                         showRatingModal('driver', 'Please rate your driver for this ride.');
                     }
                 }
             });

             connection.on("DriverRated", function (rideId, rating) {
                 if (rideId == @Model.Id) {
                     // Show success message for driver rating
                     alert(`Driver has been rated ${rating} star${rating > 1 ? 's' : ''}!`);
                     
                     // Check if both parties have rated (only if user hasn't rated yet)
                     if (!@isDriver.ToString().ToLower()) {
                         checkBothRated();
                     }
                 }
             });

             // Mark listeners as set up
             window.signalRListenersSet = true;
    }

    // Driver functions
    async function startRide() {
        if (confirm("Are you sure you want to start the ride?")) {
            try {
                console.log('Start ride called for ride:', currentRideId);
                
                const response = await fetch('/Ride/StartRide', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: currentRideId })
                });

                console.log('Start ride response status:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Start ride success:', data);
                    
                    // Update ride status display immediately
                    updateRideStatusDisplay("InProgress");
                    
                    // Show success message
                    alert(data.message);
                } else {
                    const errorData = await response.json();
                    console.error('Start ride error:', errorData);
                    alert("Error starting ride: " + (errorData.message || "Unknown error"));
                }
            } catch (err) {
                console.error("Start ride error:", err);
                alert("Error starting ride. Please try again.");
            }
        }
    }

    async function completeRide() {
        if (confirm("Are you sure you want to complete the ride?")) {
            try {
                console.log('Complete ride called for ride:', currentRideId);
                
                const response = await fetch('/Ride/CompleteRide', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: currentRideId })
                });

                console.log('Complete ride response status:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Complete ride success:', data);
                    
                    // Update ride status display immediately
                    updateRideStatusDisplay("Completed");
                    
                    // Show rating modal for driver to rate user
                    if (@isDriver.ToString().ToLower()) {
                        showRatingModal('user', 'Please rate your passenger for this ride.');
                    }
                } else {
                    const errorData = await response.json();
                    console.error('Complete ride error:', errorData);
                    alert("Error completing ride: " + (errorData.message || "Unknown error"));
                }
            } catch (err) {
                console.error("Complete ride error:", err);
                alert("Error completing ride. Please try again.");
            }
        }
    }

    // Remove duplicate function - use the async version below

        // Cancel ride function for both roles
    async function cancelRide() {
        if (confirm("Are you sure you want to cancel this ride?")) {
            try {
                                 // Ensure SignalR connection is ready
                 if (!connection || !isConnected) {
                     await initializeConnection();
                     
                     // Wait a bit for connection to stabilize
                     await new Promise(resolve => setTimeout(resolve, 1000));
                 }
                 
                 const response = await fetch('/Ride/CancelRide', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({ 
                         id: @Model.Id, 
                         rideGroup: 'ride-@Model.Id' 
                     })
                 });

                 if (response.ok) {
                     const data = await response.json();
                     
                     // Hide the cancel button immediately
                     const cancelBtn = document.getElementById('cancelRideBtn');
                     if (cancelBtn) {
                         cancelBtn.style.display = 'none';
                     }
                     
                     // Update ride status display immediately
                     updateRideStatusDisplay("Cancelled");
                     
                     // Show success message
                     alert(data.message);
                 } else {
                     const errorData = await response.json();
                     alert("Error cancelling ride: " + (errorData.message || "Unknown error"));
                 }
            } catch (err) {
                console.error("Error:", err);
                alert("Error cancelling ride. Please try again.");
            }
        }
    }


    // Function to update ride status display
    function updateRideStatusDisplay(status) {
        console.log('updateRideStatusDisplay called with status:', status);
        
        // Check if this status has already been displayed for this ride
        const statusKey = `statusDisplayed_${currentRideId}_${status}`;
        if (window[statusKey]) {
            console.log(`Status ${status} already displayed for this ride, skipping...`);
            return;
        }
        
        const statusInfo = document.querySelector('.ride-status-info');
        const statusBadge = document.getElementById('statusBadge');
        
        if (statusInfo) {
            if (status === "Cancelled") {
                // Update the status info section
                statusInfo.innerHTML = `
                    <h4 style="color: #dc3545; margin: 0;">‚ùå Ride Cancelled</h4>
                    <p style="margin: 10px 0 0 0; color: #721c24;">This ride has been cancelled.</p>
                `;
                statusInfo.style.backgroundColor = '#f8d7da';
                statusInfo.style.borderLeftColor = '#dc3545';
            } else if (status === "Pending") {
                statusInfo.innerHTML = `
                    <h4 style="color: #6c757d; margin: 0;">‚è≥ Ride Pending</h4>
                    <p style="margin: 10px 0 0 0; color: #495057;">Waiting for driver to accept your ride request.</p>
                `;
                statusInfo.style.backgroundColor = '#f8f9fa';
                statusInfo.style.borderLeftColor = '#6c757d';
            } else if (status === "Accepted") {
                statusInfo.innerHTML = `
                    <h4 style="color: #28a745; margin: 0;">‚úÖ Ride Accepted</h4>
                    <p style="margin: 10px 0 0 0; color: #155724;">Your ride is confirmed and on the way!</p>
                `;
                statusInfo.style.backgroundColor = '#e8f5e8';
                statusInfo.style.borderLeftColor = '#28a745';
            } else if (status === "DriverWaiting") {
                statusInfo.innerHTML = `
                    <h4 style="color: #17a2b8; margin: 0;">üöó Driver Waiting at Pickup</h4>
                    <p style="margin: 10px 0 0 0; color: #0c5460;">Driver has arrived at pickup location. Please proceed to the vehicle.</p>
                `;
                statusInfo.style.backgroundColor = '#d1ecf1';
                statusInfo.style.borderLeftColor = '#17a2b8';
            } else if (status === "InProgress") {
                statusInfo.innerHTML = `
                    <h4 style="color: #ffc107; margin: 0;">üöÄ Ride In Progress</h4>
                    <p style="margin: 10px 0 0 0; color: #856404;">Your ride is now in progress!</p>
                `;
                statusInfo.style.backgroundColor = '#fff3cd';
                statusInfo.style.borderLeftColor = '#ffc107';
            } else if (status === "Completed") {
                statusInfo.innerHTML = `
                    <h4 style="color: #28a745; margin: 0;">‚úÖ Ride Completed</h4>
                    <p style="margin: 10px 0 0 0; color: #155724;">Your ride has been completed successfully!</p>
                `;
                statusInfo.style.backgroundColor = '#e8f5e8';
                statusInfo.style.borderLeftColor = '#28a745';
            } else if (status === "Rejected") {
                statusInfo.innerHTML = `
                    <h4 style="color: #dc3545; margin: 0;">‚ùå Ride Rejected</h4>
                    <p style="margin: 10px 0 0 0; color: #721c24;">This ride has been rejected.</p>
                `;
                statusInfo.style.backgroundColor = '#f8d7da';
                statusInfo.style.borderLeftColor = '#dc3545';
            }
        }
        
        if (statusBadge) {
            if (status === "Cancelled") {
                statusBadge.textContent = "Cancelled";
                statusBadge.style.backgroundColor = "#dc3545";
            } else if (status === "Pending") {
                statusBadge.textContent = "Pending";
                statusBadge.style.backgroundColor = "#6c757d";
            } else if (status === "Accepted") {
                statusBadge.textContent = "Accepted";
                statusBadge.style.backgroundColor = "#28a745";
            } else if (status === "DriverWaiting") {
                statusBadge.textContent = "Driver Waiting";
                statusBadge.style.backgroundColor = "#17a2b8";
            } else if (status === "InProgress") {
                statusBadge.textContent = "In Progress";
                statusBadge.style.backgroundColor = "#ffc107";
            } else if (status === "Completed") {
                statusBadge.textContent = "Completed";
                statusBadge.style.backgroundColor = "#28a745";
            } else if (status === "Rejected") {
                statusBadge.textContent = "Rejected";
                statusBadge.style.backgroundColor = "#dc3545";
            }
        }
        
        // Show the Back to Home button when ride is cancelled or completed
        if (status === "Cancelled" || status === "Completed") {
            showBackToHomeButton();
        }
        
        // Update button visibility based on status (only if not already updated for this status)
        const buttonVisibilityKey = `buttonVisibilityUpdated_${currentRideId}_${status}`;
        if (!window[buttonVisibilityKey]) {
            updateButtonVisibility(status);
            window[buttonVisibilityKey] = true;
            console.log(`Button visibility updated for status: ${status}`);
        } else {
            console.log(`Button visibility already updated for status: ${status}, skipping...`);
        }
        
        // Show ride price prominently when completed
        if (status === "Completed") {
            showRidePrice();
        }
        
        // Mark that this status has been displayed for this ride
        window[statusKey] = true;
        console.log(`Status ${status} displayed and marked as shown for this ride`);
    }
    
    // Function to initialize buttons based on current ride status
    function initializeButtons(status) {
        console.log('initializeButtons called with status:', status);
        
        // Check if user is driver by looking for driver buttons
        const arrivedBtn = document.getElementById('arrivedAtPickupBtn');
        const startBtn = document.getElementById('startRideBtn');
        const completeBtn = document.getElementById('completeRideBtn');
        
        if (arrivedBtn && startBtn && completeBtn) {
            console.log('User is driver, initializing buttons for status:', status);
            
            // Hide all buttons first
            arrivedBtn.style.display = 'none';
            startBtn.style.display = 'none';
            completeBtn.style.display = 'none';
            
            // Show appropriate button based on status
            switch (status) {
                case "Accepted":
                    arrivedBtn.style.display = 'inline-block';
                    console.log('Initialized: showing arrived button');
                    break;
                case "DriverWaiting":
                    startBtn.style.display = 'inline-block';
                    console.log('Initialized: showing start button');
                    break;
                case "InProgress":
                    completeBtn.style.display = 'inline-block';
                    console.log('Initialized: showing complete button');
                    break;
                default:
                    console.log('Initialized: no buttons shown for status:', status);
                    break;
            }
        } else {
            console.log('User is not driver or buttons not found');
        }
    }
    
    // Function to update button visibility based on ride status
    function updateButtonVisibility(status) {
        console.log('updateButtonVisibility called with status:', status);
        
        const arrivedBtn = document.getElementById('arrivedAtPickupBtn');
        const startBtn = document.getElementById('startRideBtn');
        const completeBtn = document.getElementById('completeRideBtn');
        const cancelBtn = document.getElementById('cancelRideBtn');
        
        console.log('Button elements found:', { 
            arrivedBtn: !!arrivedBtn, 
            startBtn: !!startBtn, 
            completeBtn: !!completeBtn, 
            cancelBtn: !!cancelBtn 
        });
        
        // Hide all driver buttons first
        if (arrivedBtn) arrivedBtn.style.display = 'none';
        if (startBtn) startBtn.style.display = 'none';
        if (completeBtn) completeBtn.style.display = 'none';
        
        // Show buttons based on status (only for drivers)
        if (arrivedBtn && startBtn && completeBtn) { // Check if user is driver
            switch (status) {
                case "Accepted":
                    arrivedBtn.style.display = 'inline-block';
                    console.log('Showing arrived button');
                    break;
                case "DriverWaiting":
                    startBtn.style.display = 'inline-block';
                    console.log('Showing start button');
                    break;
                case "InProgress":
                    completeBtn.style.display = 'inline-block';
                    console.log('Showing complete button');
                    break;
            }
        }
        
        // Cancel button is always visible unless ride is completed or cancelled
        if (cancelBtn && (status === "Completed" || status === "Cancelled")) {
            cancelBtn.style.display = 'none';
        }
        
        console.log('Button visibility updated for status:', status);
    }
    
    // Function to show the Back to Home button
    function showBackToHomeButton() {
        // Check if back to home button has already been shown for this ride
        if (window.backToHomeShown) {
            console.log('Back to home button already shown, skipping...');
            return;
        }
        
        // Create the Back to Home button if it doesn't exist
        let backButton = document.querySelector('.back-to-home-btn');
        if (!backButton) {

            backButton = document.createElement('a');
            backButton.href = "@backHref";
            backButton.className = 'back-to-home-btn';
            backButton.style.cssText = 'display: inline-block; padding: 15px 30px; background-color: #6c757d; color: white; text-decoration: none; border-radius: 8px; font-size: 16px; margin: 0 10px;';
            backButton.innerHTML = 'üè† Back to Home';
            
            // Insert after the action buttons div
            const actionButtonsDiv = document.querySelector('.action-buttons');
            if (actionButtonsDiv) {
                actionButtonsDiv.appendChild(backButton);
            }
        }
        
        // Mark that back to home button has been shown
        window.backToHomeShown = true;
        console.log('Back to home button displayed and marked as shown');
    }
    
    // Function to show ride price prominently
    function showRidePrice() {
        // Check if price has already been shown for this ride
        if (window.ridePriceShown) {
            console.log('Ride price already shown, skipping...');
            return;
        }
        
        // Remove any existing price display to prevent duplicates
        const existingPrice = document.getElementById('completedRidePrice');
        if (existingPrice) {
            existingPrice.remove();
        }
        
        const price = document.getElementById('price').textContent;
        const priceDisplay = document.createElement('div');
        priceDisplay.id = 'completedRidePrice';
        priceDisplay.style.cssText = 'background-color: #28a745; color: white; padding: 20px; border-radius: 8px; text-align: center; margin: 20px 0; font-size: 18px; font-weight: bold;';
        priceDisplay.innerHTML = `üéâ Ride Completed! Total Price: ${price}`;
        
        // Insert before the action buttons
        const actionButtonsDiv = document.querySelector('.action-buttons');
        if (actionButtonsDiv) {
            actionButtonsDiv.parentNode.insertBefore(priceDisplay, actionButtonsDiv);
        }
        
        // Mark that price has been shown
        window.ridePriceShown = true;
        console.log('Ride price displayed and marked as shown');
    }

    // Rating system functions
    function showRatingModal(target, message) {
        // Check if rating modal has already been shown for this target
        const ratingKey = `ratingModalShown_${currentRideId}_${target}`;
        if (window[ratingKey]) {
            console.log(`Rating modal already shown for ${target}, skipping...`);
            return;
        }
        
        ratingTarget = target;
        currentRating = 0;
        
        document.getElementById('ratingModalTitle').textContent = `Rate ${target === 'user' ? 'Passenger' : 'Driver'}`;
        document.getElementById('ratingModalMessage').textContent = message;
        document.getElementById('selectedRating').innerHTML = '<span style="font-size: 18px; color: #6c757d;">Select a rating</span>';
        document.getElementById('submitRatingBtn').disabled = true;
        
        // Reset star colors
        document.querySelectorAll('.star').forEach(star => {
            star.style.color = '#ddd';
        });
        
        document.getElementById('ratingModal').style.display = 'block';
        
        // Mark that rating modal has been shown for this target
        window[ratingKey] = true;
        console.log(`Rating modal displayed for ${target} and marked as shown`);
    }

    function closeRatingModal() {
        document.getElementById('ratingModal').style.display = 'none';
        currentRating = 0;
        ratingTarget = '';
    }

    function selectRating(rating) {
        currentRating = rating;
        
        // Update star colors
        document.querySelectorAll('.star').forEach((star, index) => {
            if (index < rating) {
                star.style.color = '#ffc107';
            } else {
                star.style.color = '#ddd';
            }
        });
        
        // Update selected rating text
        document.getElementById('selectedRating').innerHTML = `<span style="font-size: 18px; color: #28a745;">${rating} star${rating > 1 ? 's' : ''} selected</span>`;
        document.getElementById('submitRatingBtn').disabled = false;
    }

    async function submitRating() {
        if (currentRating === 0 || !ratingTarget) {
            alert('Please select a rating');
            return;
        }

        try {
            const endpoint = ratingTarget === 'user' ? '/Ride/AddUserRating' : '/Ride/AddDriverRating';
            const requestBody = { 
                RideId: currentRideId, 
                Rating: currentRating 
            };
            
            console.log('Submitting rating:', { endpoint, requestBody, currentRideId, currentRating, ratingTarget });
            
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            console.log('Rating response status:', response.status);

            if (response.ok) {
                const data = await response.json();
                console.log('Rating success:', data);
                alert(data.message);
                closeRatingModal();
                
                // Mark this user as rated
                markUserAsRated();
                
                // Check if both parties have rated
                checkBothRated();
            } else {
                let errorMessage = "Unknown error";
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.message || "Unknown error";
                    console.error('Rating error response:', errorData);
                } catch (parseError) {
                    // If response is not JSON, try to get it as text
                    try {
                        const errorText = await response.text();
                        errorMessage = errorText || "Unknown error";
                        console.error('Rating error text:', errorText);
                    } catch (textError) {
                        console.error('Could not read error response:', textError);
                    }
                }
                alert("Error submitting rating: " + errorMessage);
            }
        } catch (err) {
            console.error("Rating submission error:", err);
            alert("Error submitting rating. Please try again.");
        }
    }

    // Driver workflow functions
    async function driverArrived() {
        if (confirm("Are you sure you have arrived at the pickup location?")) {
            try {
                console.log('Driver arrived called for ride:', currentRideId);
                
                const response = await fetch('/Ride/DriverArrived', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ id: currentRideId })
                });

                console.log('Driver arrived response status:', response.status);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Driver arrived success:', data);
                    
                    // Update ride status display immediately
                    updateRideStatusDisplay("DriverWaiting");
                    
                    // Show success message
                    alert(data.message);
                } else {
                    const errorData = await response.json();
                    console.error('Driver arrived error:', errorData);
                    alert("Error updating ride status: " + (errorData.message || "Unknown error"));
                }
            } catch (err) {
                console.error("Driver arrived error:", err);
                alert("Error updating ride status. Please try again.");
            }
        }
    }

    // Function to check if user has already rated
    function hasUserRated() {
        return localStorage.getItem(`rated_${currentRideId}_${ratingTarget}`) === 'true';
    }
    
    // Function to mark user as rated
    function markUserAsRated() {
        localStorage.setItem(`rated_${currentRideId}_${ratingTarget}`, 'true');
    }
    
    // Function to check if both parties have rated
    function checkBothRated() {
        // Check if this function has already been called for this ride
        const checkKey = `checkBothRatedCalled_${currentRideId}`;
        if (window[checkKey]) {
            console.log('checkBothRated already called for this ride, skipping...');
            return;
        }
        
        const driverRated = localStorage.getItem(`rated_${currentRideId}_user`) === 'true';
        const userRated = localStorage.getItem(`rated_${currentRideId}_driver`) === 'true';
        
        console.log(`Checking ratings - Driver rated: ${driverRated}, User rated: ${userRated}`);
        
        if (driverRated && userRated) {
            console.log('Both parties have rated, showing back to home button');
            showBackToHomeButton();
        }
        
        // Mark that this function has been called for this ride
        window[checkKey] = true;
        console.log('checkBothRated marked as called for this ride');
    }
    
    // SignalR event listeners are now set up in setupSignalRListeners() function
    // which is called after the connection is established

    // Initialize everything when page loads
     document.addEventListener('DOMContentLoaded', async function() {
         // Clear any existing rating data for this ride
         localStorage.removeItem(`rated_${@Model.Id}_user`);
         localStorage.removeItem(`rated_${@Model.Id}_driver`);

         
         // Check if ride is already cancelled and update UI accordingly
         const currentStatus = '@Model.Status.ToString()';
         console.log('Page loaded with ride status:', currentStatus);
         
         // Check if we're in the middle of a rating process
         const driverRated = localStorage.getItem(`rated_${@Model.Id}_user`) === 'true';
         const userRated = localStorage.getItem(`rated_${@Model.Id}_driver`) === 'true';
         if (currentStatus === 'Cancelled') {
             updateRideStatusDisplay("Cancelled");
             
             // Show the Back to Home button if ride is already cancelled
             showBackToHomeButton();
         } else if (currentStatus === 'Completed') {
             updateRideStatusDisplay("Completed");
             
             // Show the Back to Home button
             showBackToHomeButton();
             
             // Show rating modal if user hasn't rated yet
             if (!@isDriver) {
                 // User should rate the driver first
                 if (!userRated) {
                     showRatingModal('driver', 'Please rate your driver for this ride.');
                 } else if (driverRated) {
                     // Both have rated, show back to home
                     showBackToHomeButton();
                 }
             } else {
                 // Driver should rate the user first
                 if (!driverRated) {
                     showRatingModal('user', 'Please rate your passenger for this ride.');
                 } else if (userRated) {
                     // Both have rated, show back to home
                     showBackToHomeButton();
                 }
             }
         } else {
             // For other statuses, update button visibility automatically
             updateRideStatusDisplay(currentStatus);
         }
         
         // Always update button visibility for initial state (only if not already updated)
         const initialButtonVisibilityKey = `buttonVisibilityUpdated_${@Model.Id}_${currentStatus}`;
         if (!window[initialButtonVisibilityKey]) {
             updateButtonVisibility(currentStatus);
             window[initialButtonVisibilityKey] = true;
             console.log(`Initial button visibility updated for status: ${currentStatus}`);
         } else {
             console.log(`Initial button visibility already updated for status: ${currentStatus}, skipping...`);
         }
         
         // Initialize buttons based on current status (only if not already initialized)
         const initializeButtonsKey = `buttonsInitialized_${@Model.Id}_${currentStatus}`;
         if (!window[initializeButtonsKey]) {
             initializeButtons(currentStatus);
             window[initializeButtonsKey] = true;
             console.log(`Buttons initialized for status: ${currentStatus}`);
         } else {
             console.log(`Buttons already initialized for status: ${currentStatus}, skipping...`);
         }
         
         // Initialize SignalR status
         updateSignalRStatus("Initializing...", "#6c757d");
         
         // AUTO-CONNECT SIGNALR IMMEDIATELY
         try {
             await initializeConnection();
         } catch (error) {
             console.error('SignalR auto-connection failed:', error);
             // Retry after a delay
             setTimeout(async () => {
                 try {
                     await initializeConnection();
                 } catch (retryError) {
                     console.error('SignalR retry failed:', retryError);
                 }
             }, 2000);
         }
         
         // Add event listeners for rating stars
         document.querySelectorAll('.star').forEach(star => {
             star.addEventListener('click', function() {
                 selectRating(parseInt(this.dataset.rating));
             });
         });
         
                            const mapContainer = document.getElementById('rideMap');
        
        // Check if container has proper dimensions
        if (mapContainer && (mapContainer.offsetWidth === 0 || mapContainer.offsetHeight === 0)) {
            console.warn('Map container has zero dimensions, this might cause the map not to appear');
        }
        
        // Try immediate initialization first
         if (typeof L !== 'undefined' && mapContainer && mapContainer.offsetWidth > 0 && mapContainer.offsetHeight > 0 && !window.mapInitialized) {
            try {
                initializeMap();
                return;
            } catch (error) {
                     // Fall back to retry logic
                 }
         }
         
         // Start automatic map initialization with retry logic (only if not already initialized)
         if (!window.mapInitialized) {
             autoInitializeMap();
         }
    });
    
    // Also try to initialize when window is fully loaded (backup)
         window.addEventListener('load', async function() {
             // Ensure SignalR is connected
             if (!connection || !isConnected) {
                 try {
                     await initializeConnection();
                 } catch (error) {
                     console.error('Failed to connect SignalR on window load:', error);
                 }
             }
             
             // Only initialize map if it hasn't been initialized yet
             if (!map && !window.mapInitialized) {
            autoInitializeMap();
        }
    });
    
    // Automatic map initialization with retry logic
         async function autoInitializeMap() {
             // Prevent multiple auto-initialization calls
             if (window.autoInitInProgress) {
                 return;
             }
             
             // Prevent if map is already initialized
             if (window.mapInitialized) {
                 return;
             }
             
             window.autoInitInProgress = true;
        
        // Check if Leaflet is loaded
        if (typeof L === 'undefined') {
            // Retry after a short delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 200);
            return;
        }
        
        // Check if map container is ready
        const mapContainer = document.getElementById('rideMap');
        if (!mapContainer || mapContainer.offsetWidth === 0 || mapContainer.offsetHeight === 0) {
            // Retry after a short delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 200);
            return;
        }
        
        try {
            // Initialize the map
            initializeMap();
        } catch (error) {
                 console.error('Error during automatic map initialization:', error);
            
            // Retry after a longer delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 1000);
             } finally {
                 window.autoInitInProgress = false;
             }
         }

    
</script>
